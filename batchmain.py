# python 3.7.4
# simpleitk 1.pt.2.2

import numpy
import collections
import csv
import logging
import os
import string

import SimpleITK as sitk

import radiomics
from radiomics import featureextractor

from preprocessing import *


def main(outPath=r'', patch=None, patchsize=30, allfilters=False):
    '''
    Func that runs PyRadiomics analysis. Creates a csv file with results.

    Accepts an input CSV (pyradExcel) which indicates image and mask.

    By default runs features on whole segmentation file (mhd in our case). If want to run PyRadiomics in patches
    (grid-mode):
    (1.pt) call patch='2D' or '3D', depending on the dimensions of your Region of Interest.
    (2) in input CSV, under Slices column, indicate first and last slice in this format - X, Y (otherwise leave empty)
    '''

    inputCSV = os.path.join(outPath, 'pyradExcel.csv')
    outputFilepath = os.path.join(outPath, 'radiomics_features.csv')
    progress_filename = os.path.join(outPath, 'pyrad_log.txt')
    # params = os.path.join(outPath, 'exampleSettings', 'Params.yaml') # default fr PyR. skipped later if not found

    # Configure logging
    rLogger = logging.getLogger('radiomics')

    # Set logging level
    rLogger.setLevel(logging.INFO)  # default log level of logger is INFO

    # Create handler for writing to log file
    handler = logging.FileHandler(filename=progress_filename, mode='w')
    handler.setFormatter(logging.Formatter('%(levelname)s:%(name)s: %(message)s'))
    rLogger.addHandler(handler)

    # Initialize logging for batch log messages
    logger = rLogger.getChild('batch')

    # Set verbosity level for output to stderr (default level = WARNING) (amount of messages displayed)
    radiomics.setVerbosity(logging.INFO)

    logger.info('pyradiomics version: %s', radiomics.__version__)
    logger.info('Loading CSV')

    try:
        with open(inputCSV, 'r') as inFile:
            reader = csv.DictReader(inFile, lineterminator='\n')
            index = [row for row in reader]
    except Exception:
        logger.error('CSV READ FAILED', exc_info=True)

    logger.info('Loading Done')
    logger.info('Patients: %d', len(index))

    # Set custom geometryTolerance. This is the only setting that will overun default settings.
    # There can be a tiny delta between image and mask space direction values (ElementSpacing/Size field in mhd/mha).
    # From primary tests they should be equal upto at least 4 decimal places, so I set to 10**-4.
    settings = {}
    settings['geometryTolerance'] = 10 ** -4

    count = 0

    for idx, entry in enumerate(index, start=1):

        logger.info("(%d/%d) Processing Patient (Image: %s, Mask: %s)", idx, len(index), entry['Image'], entry['Mask'])

        imageFilepath = entry['Image']
        maskFilepath = entry['Mask']
        slices = entry['Slices'].split(', ')

        if (imageFilepath is not None) and (maskFilepath is not None):

            # Extract label from mask.
            # PyRadiomics calls on label 1.pt by default, but mhd has default 255 and Philips TISSUE mask file -1.pt.
            # From my understanding, in TISSUE mask file generated by Philips Portal there is only one label per mask
            sitkMask = sitk.ReadImage(maskFilepath)
            sitkarray = sitk.GetArrayFromImage(sitkMask)
            labels = numpy.unique(sitkarray)
            if 255 in labels:
                totalLabel = int(labels[1])
            elif -1 in labels:
                totalLabel = int(labels[0])

            # By default, only Original input image is enabled (No filter applied).
            extractor = featureextractor.RadiomicsFeatureExtractor(**settings)
            if allfilters:
                extractor.enableAllImageTypes()

            logger.info('Enabled input images types: %s', extractor.enabledImagetypes)
            logger.info('Enabled features: %s', extractor.enabledFeatures)
            logger.info('Current settings: %s', extractor.settings)

            # Checks if want to run in patch mode or whole mask
            if patch is None:

                # If mask is 3D, get full mask for later feature extraction. If 2D, leave sitkMask unchanged
                if slices != ['']:
                    sitkMask = getFullMask(imageFilepath, maskFilepath, slices)

                featureVector = collections.OrderedDict(entry)
                featureVector['Image'] = os.path.basename(imageFilepath)
                featureVector['Mask'] = os.path.basename(maskFilepath)

                try:
                    featureVector.update(extractor.execute(imageFilepath, sitkMask, totalLabel))
                    writeResults(featureVector, outputFilepath, count)
                    count += 1
                except Exception:
                    logger.error('FEATURE EXTRACTION FAILED', exc_info=True)
                    writeResults(featureVector, outputFilepath, count)
            elif patch == '3D' and slices != ['']:
                sitkMask = getFullMask(imageFilepath, maskFilepath, slices)
                sitkarray = sitk.GetArrayFromImage(sitkMask)
                patchedMask, dctLabel, dctABC = patch3Dmask(sitkarray, totalLabel, patchsize=patchsize)
                newMask = sitk.GetImageFromArray(patchedMask)
                newMask.CopyInformation(sitkMask)
                for label in dctLabel:
                    featureVector = collections.OrderedDict(entry)
                    featureVector['Image'] = os.path.basename(imageFilepath)
                    featureVector['Mask'] = os.path.basename(maskFilepath)
                    featureVector['PatchNumber'] = label
                    featureVector['PatchName'] = dctABC[label]
                    featureVector['FractionLabelInPatch'] = dctLabel[label]
                    try:
                        featureVector.update(extractor.execute(imageFilepath, newMask, label))
                        writeResults(featureVector, outputFilepath, count)
                        count += 1
                    except Exception:
                        logger.error('FEATURE EXTRACTION FAILED', exc_info=True)
                        writeResults(featureVector, outputFilepath, count)
            elif patch == '2D':
                patchedMask, dctLabel = patchMask(sitkarray, totalLabel, patchsize=patchsize)
                newMask = sitk.GetImageFromArray(patchedMask)
                newMask.CopyInformation(sitkMask)
                for label in dctLabel:
                    featureVector = collections.OrderedDict(entry)
                    featureVector['Image'] = os.path.basename(imageFilepath)
                    featureVector['Mask'] = os.path.basename(maskFilepath) + '_' + str(label)
                    featureVector['PatchNumber'] = label
                    # featureVector['PatchName'] = label # sort out alphabetical name for 2D patching as well
                    featureVector['FractionLabelInPatch'] = dctLabel[label]
                    try:
                        featureVector.update(extractor.execute(imageFilepath, newMask, label))
                        writeResults(featureVector, outputFilepath, count)
                        count += 1
                    except Exception:
                        logger.error('FEATURE EXTRACTION FAILED', exc_info=True)
                        writeResults(featureVector, outputFilepath, count)


def writeResults(featureVector, outputFilepath, count):
    '''
    Creates excel file with results from feature extraction
    '''
    with open(outputFilepath, 'a') as outputFile:
        writer = csv.writer(outputFile, lineterminator='\n')
        # assumes first run of feature extraction will succeed, otherwise won't write features headers for next rows
        headers = featureVector.keys()
        if count == 0:
            headers = list(headers)
            writer.writerow(headers)

        row = []
        for h in headers:
            row.append(featureVector.get(h, "N/A"))
        writer.writerow(row)


if __name__ == '__main__':
    main(patch='3D')
